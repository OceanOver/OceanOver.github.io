<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OceanOver&#39;Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-08T10:20:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OceanOver</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Async/Await 优雅的异步代码</title>
    <link href="http://yoursite.com/2017/04/08/Async-Await-%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2017/04/08/Async-Await-优雅的异步代码/</id>
    <published>2017-04-08T10:14:54.000Z</published>
    <updated>2017-04-08T10:20:05.000Z</updated>
    
    <content type="html">&lt;p&gt;JavaScript的异步编程方式有效提高了应用性能；但有时候使用回调函数来组织代码往往会导致代码难以阅读。Promise让我们告别回调函数，可以将嵌套的回调函数展平，写出更优雅的异步代码；在实践过程中，却发现Promise并不完美，这时，我们有了Async/Await。&lt;/p&gt;
&lt;p&gt;ES7 中有了更加标准的解决方案，新增了 async/await 两个关键词。async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。&lt;/p&gt;
&lt;h3 id=&quot;Async-Await简介&quot;&gt;&lt;a href=&quot;#Async-Await简介&quot; class=&quot;headerlink&quot; title=&quot;Async/Await简介&quot;&gt;&lt;/a&gt;Async/Await简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;async/await是基于Promise实现的，它不能用于普通的回调函数。&lt;/li&gt;
&lt;li&gt;async/await与Promise一样，是非阻塞的。&lt;/li&gt;
&lt;li&gt;async/await使得异步代码看起来像同步代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;说说Promise&quot;&gt;&lt;a href=&quot;#说说Promise&quot; class=&quot;headerlink&quot; title=&quot;说说Promise&quot;&gt;&lt;/a&gt;说说Promise&lt;/h3&gt;&lt;p&gt;先以 Promise 实例展示&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; results = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  data: [&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      content: &lt;span class=&quot;string&quot;&gt;&#39;test content1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      content: &lt;span class=&quot;string&quot;&gt;&#39;test content2&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getPosts&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;resolve&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resolve(results)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getPosts().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在 1 秒后 resolve 一個模拟的 result，catch能处理JSON.parse错误&lt;/p&gt;
&lt;h3 id=&quot;如果是-Async-Await&quot;&gt;&lt;a href=&quot;#如果是-Async-Await&quot; class=&quot;headerlink&quot; title=&quot;如果是 Async/Await&quot;&gt;&lt;/a&gt;如果是 Async/Await&lt;/h3&gt;&lt;p&gt;有了 async/await 之后，我们就可以这样实现了：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printResult&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;执行请求前&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; getPosts()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;执行请求后&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (err) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(err);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;printResult()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;await getPosts()表示会等到getPosts的promise成功reosolve之后再执行。async 函数可以正常的返回结果和抛出异常。await 函数调用即可拿到结果，在外面包上 try/catch 就可以捕获异常。async/await使得异步代码看起来像同步代码&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;Async/Await是近年来JavaScript添加的最革命性的特性之一。它会让你发现Promise的语法不完美，而且提供了一个直观的替代方法。&lt;/p&gt;
&lt;p&gt;ES7 还在草案阶段，那现在想用这个特性：&lt;/p&gt;
&lt;h4 id=&quot;在前端&quot;&gt;&lt;a href=&quot;#在前端&quot; class=&quot;headerlink&quot; title=&quot;在前端&quot;&gt;&lt;/a&gt;在前端&lt;/h4&gt;&lt;p&gt;例如在写React的时候，基本上已经使用了 babel。如果要使用 Async/Await，presets 除了原本的 es2015 外，只要加上 stage-3：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.bebalrc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;span class=&quot;string&quot;&gt;&quot;es2015&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;stage-3&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;在后端&quot;&gt;&lt;a href=&quot;#在后端&quot; class=&quot;headerlink&quot; title=&quot;在后端&quot;&gt;&lt;/a&gt;在后端&lt;/h4&gt;&lt;p&gt;Node 7.0.0 起已经支持 Async/Await，Node 7不是LTS（长期支持版本），但是，Node 8很快就会发布，将代码迁移到新版本会非常简单。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript的异步编程方式有效提高了应用性能；但有时候使用回调函数来组织代码往往会导致代码难以阅读。Promise让我们告别回调函数，可以将嵌套的回调函数展平，写出更优雅的异步代码；在实践过程中，却发现Promise并不完美，这时，我们有了Async/Await。&lt;/p&gt;
&lt;p&gt;ES7 中有了更加标准的解决方案，新增了 async/await 两个关键词。async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。&lt;/p&gt;
&lt;h3 id=&quot;Async-Await简介&quot;&gt;&lt;a href=&quot;#Async-Await简介&quot; class=&quot;headerlink&quot; title=&quot;Async/Await简介&quot;&gt;&lt;/a&gt;Async/Await简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;async/await是基于Promise实现的，它不能用于普通的回调函数。&lt;/li&gt;
&lt;li&gt;async/await与Promise一样，是非阻塞的。&lt;/li&gt;
&lt;li&gt;async/await使得异步代码看起来像同步代码。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习之正则篇</title>
    <link href="http://yoursite.com/2017/01/07/JavaScript-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%AD%A3%E5%88%99%E7%AF%87/"/>
    <id>http://yoursite.com/2017/01/07/JavaScript-学习之正则篇/</id>
    <published>2017-01-07T03:40:16.000Z</published>
    <updated>2017-01-07T03:43:14.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;正则表达式可以极大的提高复杂文本分析的效率，快速匹配出复杂的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;字符&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;将下一个字符标记为一个特殊字符、或一个原义字符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配输入字符串的开始位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配输入字符串的结束位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;{n}&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;{n,}&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;{n,m}&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;m和n均为非负整数，其中n&amp;lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配前面的子表达式零次或多次。例如，zo&lt;em&gt;能匹配“z”、“zo”以及“zoo”。&lt;/em&gt;等价于{0,}。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;(pattern)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符，请使用 \( 和 \)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;x｜y&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配x或y。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;[xyz]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;[^xyz]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;[^a-z]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\w&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配包括下划线的任何单词字符。等价于 [a-zA-Z0-9_]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\W&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配任何非单词字符。等价于 [^a-zA-Z0-9_]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\s&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\S&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\d&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配一个数字字符。等价于 [0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配一个非数字字符。等价于 [^0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\b&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\B&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示词首。 例如\&amp;lt;abc表示以abc为首的词。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;\&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示词尾。 例如abc&gt;表示以abc结尾的词。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;优先级&quot;&gt;&lt;a href=&quot;#优先级&quot; class=&quot;headerlink&quot; title=&quot;优先级&quot;&gt;&lt;/a&gt;优先级&lt;/h4&gt;&lt;p&gt;优先级为从上到下从左到右，依次降低：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;运算符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;‘\’&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;转义符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;‘(), (?:), (?=), []’&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;括号和中括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;‘*、+、?、{n}、{n,}、{n,m}’&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;限定符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;‘^、$、\任何元字符’&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;定位点和序列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;‘｜’&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;选择&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;创建正则表达式&quot;&gt;&lt;a href=&quot;#创建正则表达式&quot; class=&quot;headerlink&quot; title=&quot;创建正则表达式&quot;&gt;&lt;/a&gt;创建正则表达式&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字面量&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; expression = &lt;span class=&quot;regexp&quot;&gt;/pattern/&lt;/span&gt;flags ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//pattern 是要匹配的字符串模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//flags用来标记正则表达式的行为: i 不区分大小写；g 表示全局搜索 ；m 表示多行模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reg = &lt;span class=&quot;regexp&quot;&gt;/ab/i&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//表示匹配 字符串 &#39;ab&#39; 不区分大小写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RegExp对象的构造函数&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; expression = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;(pattern,flags)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//flags 和直接量语法一致&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//pattern 可以是字符串模式，也可以是一个标准的正则表达式，后者必须省略 flags&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//两种写法均可&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reg = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;ab&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;i&#39;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reg = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;regexp&quot;&gt;/ab/i&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;RegExp的方法&quot;&gt;&lt;a href=&quot;#RegExp的方法&quot; class=&quot;headerlink&quot; title=&quot;RegExp的方法&quot;&gt;&lt;/a&gt;RegExp的方法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;exec()&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;该方法对一个指定的字符串执行一个正则表达式，执行正则表达式的匹配，返回一个数组。没有匹配到则返回 &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;，返回的数组是&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;的实例，而且返回值还包含另外&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;个属性：index： 匹配到的字符位于原始字符串的基于&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;的索引值 和 input： 原始字符串&lt;span class=&quot;string&quot;&gt;`。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myRe = &lt;span class=&quot;regexp&quot;&gt;/ab*/g&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&#39;abbcdefabh&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; oo = myRe.exec(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(oo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//[ &#39;abb&#39;, index: 0, input: &#39;abbcdefabh&#39; ]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;oo = myRe.exec(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(oo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//[ &#39;ab&#39;, index: 7, input: &#39;abbcdefabh&#39; ]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;当正则表达式使用 “g” 标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的 lastIndex 属性指定的位置开始。&lt;br&gt;不加”g” 标志的时候，每次都是从 0 开始，所以各种属性也不会改变&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;test()&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;接收一个字符串参数，regexObj.&lt;span class=&quot;built_in&quot;&gt;exec&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;),如果包含正则表达式的一个匹配结果返回&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;，否则&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; pattern = &lt;span class=&quot;regexp&quot;&gt;/java/i&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result = pattern.test(&lt;span class=&quot;string&quot;&gt;&#39;javascript&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(result); &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;toString()&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt; 对象覆盖了 &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt; 对象的 toString() 方法，并没有继承 &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.prototype.toString()。对于 &lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt; 对象，toString 方法返回一个该正则表达式的字面量。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;myExp = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;a+b+c&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(myExp.toString());  &lt;span class=&quot;comment&quot;&gt;// 结果: /a+b+c/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;g&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(foo.toString());   &lt;span class=&quot;comment&quot;&gt;// 结果: /bar/g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;用于模式匹配的String方法&quot;&gt;&lt;a href=&quot;#用于模式匹配的String方法&quot; class=&quot;headerlink&quot; title=&quot;用于模式匹配的String方法&quot;&gt;&lt;/a&gt;用于模式匹配的String方法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;String.search()&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;参数：一个正则表达式。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回：它返回匹配到的位置索引，或者在失败时返回-1。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//查找连续2个数字的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;a1b2c33d4&#39;&lt;/span&gt;.search(&lt;span class=&quot;regexp&quot;&gt;/(\d)&amp;#123;2&amp;#125;/&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;String.replace()&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;一个在字符串中执行查找匹配的&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;方法，并且使用替换字符串替换掉匹配到的子字符串。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;121212&#39;&lt;/span&gt;.replace(&lt;span class=&quot;regexp&quot;&gt;/1/g&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;,&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&quot;,2,2,2&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;String.match()&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;参数：一个正则表达式。一个在字符串中执行查找匹配的&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;方法，它返回一个数组或者在未匹配到时返回&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设置g则返回所有匹配结果，否则数组的第一个元素是匹配的字符串，剩下的是圆括号中的子表达式&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; matchResult = &lt;span class=&quot;string&quot;&gt;&#39;121212&#39;&lt;/span&gt;.match(&lt;span class=&quot;regexp&quot;&gt;/1/g&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(matchResult);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matchResult = &lt;span class=&quot;string&quot;&gt;&#39;121212&#39;&lt;/span&gt;.match(&lt;span class=&quot;regexp&quot;&gt;/1/&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(matchResult);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//[ &#39;1&#39;, index: 0, input: &#39;121212&#39; ]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;String.split()&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//以数字分割字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;a1b2c33d4&#39;&lt;/span&gt;.split(&lt;span class=&quot;regexp&quot;&gt;/\d*/&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/45cccb9ca3e9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;常用javascript正则表达式&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正则表达式可以极大的提高复杂文本分析的效率，快速匹配出复杂的字符串。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6函数拓展 - 箭头函数</title>
    <link href="http://yoursite.com/2017/01/07/ES6%E5%87%BD%E6%95%B0%E6%8B%93%E5%B1%95-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/01/07/ES6函数拓展-箭头函数/</id>
    <published>2017-01-07T03:35:16.000Z</published>
    <updated>2017-01-07T03:38:53.000Z</updated>
    
    <content type="html">&lt;p&gt;ES6允许使用“箭头”（=&amp;gt;）定义函数，且总是匿名函数。&lt;/p&gt;
&lt;h4 id=&quot;1-基本语法&quot;&gt;&lt;a href=&quot;#1-基本语法&quot; class=&quot;headerlink&quot; title=&quot;1.基本语法&quot;&gt;&lt;/a&gt;1.基本语法&lt;/h4&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(param1, param2, …, paramN) =&amp;gt; &amp;#123; statements &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(param1, param2, …, paramN) =&amp;gt; expression&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//等同于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(param1, param2, …, paramN) =&amp;gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; expression; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果只有一个参数，圆括号是可选的:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;singleParam =&amp;gt; &amp;#123; statements &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 无参数的函数需要使用圆括号:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;() =&amp;gt; &amp;#123; statements &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;例如以下箭头函数:&lt;br&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f = v =&amp;gt; v;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;等价于:&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;v&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = (string1, string2) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; num1 = &lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.parseInt(string1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; num2 = &lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.parseInt(string2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var getItem = &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; =&amp;gt; (&amp;#123; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, name: &lt;span class=&quot;string&quot;&gt;&quot;Item&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;箭头函数极大的简化了回调函数&lt;br&gt;&lt;figure class=&quot;highlight cos&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 正常函数写法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;].map(function (&lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 箭头函数写法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;].map(&lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; =&amp;gt; &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-箭头函数体内的this对象&quot;&gt;&lt;a href=&quot;#2-箭头函数体内的this对象&quot; class=&quot;headerlink&quot; title=&quot;2.箭头函数体内的this对象&quot;&gt;&lt;/a&gt;2.箭头函数体内的this对象&lt;/h4&gt;&lt;p&gt;在箭头函数出现之前，每个新定义的函数都有自己的this值。&lt;/p&gt;
&lt;p&gt;构造函数的this指向新的实例对象，如果函数是作为对象的方法被调用的，则this指向调用它的那个对象&lt;/p&gt;
&lt;p&gt;箭头函数内:&lt;/p&gt;
&lt;p&gt;函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。且箭头函数不可以当作构造函数，也就是说，不可以使用new命令&lt;br&gt;&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ES6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function foo() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;id:&#39;&lt;/span&gt;, this.id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ES5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function foo() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var &lt;span class=&quot;built_in&quot;&gt;_this&lt;/span&gt; = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;id:&#39;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;_this&lt;/span&gt;.id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从转换后的ES5代码说明了，箭头函数里面是引用外层的this。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;ES6允许使用“箭头”（=&amp;gt;）定义函数，且总是匿名函数。&lt;/p&gt;
&lt;h4 id=&quot;1-基本语法&quot;&gt;&lt;a href=&quot;#1-基本语法&quot; class=&quot;headerlink&quot; title=&quot;1.基本语法&quot;&gt;&lt;/a&gt;1.基本语法&lt;/h4&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(param1, param2, …, paramN) =&amp;gt; &amp;#123; statements &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(param1, param2, …, paramN) =&amp;gt; expression&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//等同于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(param1, param2, …, paramN) =&amp;gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; expression; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果只有一个参数，圆括号是可选的:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;singleParam =&amp;gt; &amp;#123; statements &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 无参数的函数需要使用圆括号:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;() =&amp;gt; &amp;#123; statements &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Promise学习之bluebird(基础篇)</title>
    <link href="http://yoursite.com/2017/01/07/Promise%E5%AD%A6%E4%B9%A0%E4%B9%8Bbluebird-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2017/01/07/Promise学习之bluebird-基础篇/</id>
    <published>2017-01-07T03:31:26.000Z</published>
    <updated>2017-01-07T03:34:30.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;bluebird是一个第三方的Promise实现，除了Promise对象中的方法外，bluebird还有很多扩展方法。如，可以通过.spread()展开结构集、可以通过Promise.promisify()方法将一个Node回调函数包装成一个Promise实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装bluebird模块后，可以就可以通过require获取对模块的引用：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;bluebird&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;1-核心方法-常用的方法&quot;&gt;&lt;a href=&quot;#1-核心方法-常用的方法&quot; class=&quot;headerlink&quot; title=&quot;1. 核心方法(常用的方法)&quot;&gt;&lt;/a&gt;1. 核心方法(常用的方法)&lt;/h3&gt;&lt;h4 id=&quot;1-1-new-Promise-创建实例&quot;&gt;&lt;a href=&quot;#1-1-new-Promise-创建实例&quot; class=&quot;headerlink&quot; title=&quot;1.1 new Promise - 创建实例&quot;&gt;&lt;/a&gt;1.1 new Promise - 创建实例&lt;/h4&gt;&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Promise&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; resolve, &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; reject) resolver)&lt;/span&gt; -&amp;gt;&lt;/span&gt; Promise&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两个参数：resolve和reject，这两个参数被封装到所创建的Promise实例中，分别用于执行成功和执行失败时的调用。例：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;requestAsync&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;url&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; xhr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; XMLHttpRequest;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xhr.addEventListener(&lt;span class=&quot;string&quot;&gt;&quot;error&quot;&lt;/span&gt;, reject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xhr.addEventListener(&lt;span class=&quot;string&quot;&gt;&quot;load&quot;&lt;/span&gt;, resolve);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xhr.open(&lt;span class=&quot;string&quot;&gt;&quot;GET&quot;&lt;/span&gt;, url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xhr.send(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;调用：&lt;br&gt;&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;requestAsync(&lt;span class=&quot;string&quot;&gt;&#39;http://######&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(result)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 请求成功的处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(err)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 请求失败的处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-2-实例的then-方法&quot;&gt;&lt;a href=&quot;#1-2-实例的then-方法&quot; class=&quot;headerlink&quot; title=&quot;1.2 实例的then()方法&quot;&gt;&lt;/a&gt;1.2 实例的then()方法&lt;/h4&gt;&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;promise.&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(onFulfilled, onRejected)&lt;/span&gt;-&amp;gt;&lt;/span&gt; Promise&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;resolve(成功)时，onFulfilled方法会被调用&lt;/li&gt;
&lt;li&gt;reject(失败)时，onRejected方法会被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-3-实例的catch-方法&quot;&gt;&lt;a href=&quot;#1-3-实例的catch-方法&quot; class=&quot;headerlink&quot; title=&quot;1.3 实例的catch()方法&quot;&gt;&lt;/a&gt;1.3 实例的catch()方法&lt;/h4&gt;&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;promise.&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(any error) handler)&lt;/span&gt; -&amp;gt;&lt;/span&gt; Promise&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;catch()方法是promise中.then(null, handler)的便捷方法，.then链中异常会被传递到.catch中。&lt;br&gt;为了提高代码的可读性，我们可以使用promise.then处理操作成功的情况，使用promise.catch处理操作失败的情况，示例如下：&lt;br&gt;&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;promise.&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(result)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 操作成功&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(err)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 操作失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-4-spread-展开实例返回的结果数组&quot;&gt;&lt;a href=&quot;#1-4-spread-展开实例返回的结果数组&quot; class=&quot;headerlink&quot; title=&quot;1.4 .spread - 展开实例返回的结果数组&quot;&gt;&lt;/a&gt;1.4 .spread - 展开实例返回的结果数组&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;readFilesAsync&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [fs.readFileAsync(&lt;span class=&quot;string&quot;&gt;&quot;file1.txt&quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fs.readFileAsync(&lt;span class=&quot;string&quot;&gt;&quot;file2.txt&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;readFilesAsync().spread(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;file1text, file2text&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//deal with fileText&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;1-5-Promise-resolve-方法&quot;&gt;&lt;a href=&quot;#1-5-Promise-resolve-方法&quot; class=&quot;headerlink&quot; title=&quot;1.5 Promise.resolve()方法&quot;&gt;&lt;/a&gt;1.5 Promise.resolve()方法&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.resolve(obj)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例&lt;/li&gt;
&lt;li&gt;参数是一个thenable对象,thenable对象指的是具有then方法的对象(个人在实践中没有用到)&lt;/li&gt;
&lt;li&gt;参数是一个原始值，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。&lt;/li&gt;
&lt;li&gt;不带参数，直接返回一个Resolved状态的Promise对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-6-Promise-reject-方法&quot;&gt;&lt;a href=&quot;#1-6-Promise-reject-方法&quot; class=&quot;headerlink&quot; title=&quot;1.6 Promise.reject()方法&quot;&gt;&lt;/a&gt;1.6 Promise.reject()方法&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.reject(obj)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.resolve(&lt;span class=&quot;string&quot;&gt;&#39;出错了&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p.catch(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;s&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(s);   &lt;span class=&quot;comment&quot;&gt;//出错了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-Promise包装器&quot;&gt;&lt;a href=&quot;#2-Promise包装器&quot; class=&quot;headerlink&quot; title=&quot;2. Promise包装器&quot;&gt;&lt;/a&gt;2. Promise包装器&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;将一个没有Promise的API对象包装成有Promise的API对象，即将其Promise化&lt;br&gt;bluebird中有用于单个函数包装的Promise.promisify方法，也有用于对象属性包装的Promise.promisifyAll方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;2-1-Promise-promisify-单个函数对象的Promise化&quot;&gt;&lt;a href=&quot;#2-1-Promise-promisify-单个函数对象的Promise化&quot; class=&quot;headerlink&quot; title=&quot;2.1 Promise.promisify - 单个函数对象的Promise化&quot;&gt;&lt;/a&gt;2.1 Promise.promisify - 单个函数对象的Promise化&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fs&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 回调形式，这里的callback 必须是最后一个参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fs.readFile(&lt;span class=&quot;string&quot;&gt;&#39;./test.js&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err, data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// promisify 形式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; readFileAsync = &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.promisify(fs.readFile);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;readFileAsync(&lt;span class=&quot;string&quot;&gt;&#39;./test.js&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//deal with data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//deal with err&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;callBack 一定出现在异步函数的最后一个&lt;/p&gt;
&lt;p&gt;callBack 函数的调用参数中，第一个参数一定传入的是 err ，而不能是别的参数。&lt;/p&gt;
&lt;h4 id=&quot;2-2-Promise-promisifyAll-对象属性的Promise化&quot;&gt;&lt;a href=&quot;#2-2-Promise-promisifyAll-对象属性的Promise化&quot; class=&quot;headerlink&quot; title=&quot;2.2 Promise.promisifyAll - 对象属性的Promise化&quot;&gt;&lt;/a&gt;2.2 Promise.promisifyAll - 对象属性的Promise化&lt;/h4&gt;&lt;p&gt;将传入的对象实体的属性包装成Promise对象&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.promisifyall(&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fs&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fs.readFileAsync(&lt;span class=&quot;string&quot;&gt;&#39;./test.js&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//deal with data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//deal with err&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 经过 promisifyall , fs所有的函数都已经被 promise 化了。而被 promise 化的函数名变成了：原来的函数名+Async。&lt;/p&gt;
&lt;p&gt; 如果想将对象原型链上的方法也加上的话，则传入对象的原型即可，例如 Promise.promisifyAll(obj.prototype)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;bluebird是一个第三方的Promise实现，除了Promise对象中的方法外，bluebird还有很多扩展方法。如，可以通过.spread()展开结构集、可以通过Promise.promisify()方法将一个Node回调函数包装成一个Promise实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装bluebird模块后，可以就可以通过require获取对模块的引用：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;bluebird&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>react学习之组件生命周期</title>
    <link href="http://yoursite.com/2016/11/03/react%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2016/11/03/react学习之组件生命周期/</id>
    <published>2016-11-03T03:51:18.000Z</published>
    <updated>2016-11-03T04:11:18.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;学习iOS时我们会去研究视图控制器的生命周期，理解控制器从创建到销毁。联想到React，其组件也有从创建到销毁的过程。在组件的生命周期中，随着组件props或state的改变，其DOM表现形式也会有所变化。在生命周期的不同阶段，React提供了不同的处理函数使我们能够实现对组件整个生命周期内的控制和处理。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;React组件的生命周期分为：创建期、存在期、销毁&amp;amp;清理期，对应组件生命周期里的三个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mounting：已插入真实 DOM&lt;/li&gt;
&lt;li&gt;Updating：正在被重新渲染&lt;/li&gt;
&lt;li&gt;Unmounting：已移出真实 DOM&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; App = React.createClass(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  componentWillMount: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 初始化期，组件加载前调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  componentWillUpdate: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 存在期，组件状态改变后重新渲染前调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 初始化期或存在期调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;itbilu.com&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  componentWillUnmount: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 销毁&amp;amp;清理期调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;componentWillMount()&lt;/li&gt;
&lt;li&gt;componentDidMount()&lt;/li&gt;
&lt;li&gt;componentWillUpdate(object nextProps, object nextState)&lt;/li&gt;
&lt;li&gt;componentDidUpdate(object prevProps, object prevState)&lt;/li&gt;
&lt;li&gt;componentWillUnmount()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，React 还提供两种特殊状态的处理函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用&lt;/li&gt;
&lt;li&gt;shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用（灵活地利用该处理函数可以优化性能）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;组件创建&quot;&gt;&lt;a href=&quot;#组件创建&quot; class=&quot;headerlink&quot; title=&quot;组件创建&quot;&gt;&lt;/a&gt;组件创建&lt;/h3&gt;&lt;p&gt;当组件被创建、首次渲染时，都会有一系列方法会被调用。&lt;/p&gt;
&lt;p&gt;当首次创建一个组件时依次执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getDefaultProps&lt;/li&gt;
&lt;li&gt;getInitialState&lt;/li&gt;
&lt;li&gt;componentWillMount&lt;/li&gt;
&lt;li&gt;render&lt;/li&gt;
&lt;li&gt;componentDidMount&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;getDefaultProps&quot;&gt;&lt;a href=&quot;#getDefaultProps&quot; class=&quot;headerlink&quot; title=&quot;getDefaultProps&quot;&gt;&lt;/a&gt;getDefaultProps&lt;/h4&gt;&lt;p&gt;该方法只在首次创建实例被调用一次，一般用于顶级组件（没有父组件的组件）进行处理，实例化组件时这个方法会对返回默认的props属性。&lt;/p&gt;
&lt;h4 id=&quot;getInitialState&quot;&gt;&lt;a href=&quot;#getInitialState&quot; class=&quot;headerlink&quot; title=&quot;getInitialState&quot;&gt;&lt;/a&gt;getInitialState&lt;/h4&gt;&lt;p&gt;实例化组件时会被调用一次。通过这个方法，可以初始化每个实例的state。getInitialState在每次创建实例时都会被调用。&lt;/p&gt;
&lt;h4 id=&quot;componentWillMount&quot;&gt;&lt;a href=&quot;#componentWillMount&quot; class=&quot;headerlink&quot; title=&quot;componentWillMount&quot;&gt;&lt;/a&gt;componentWillMount&lt;/h4&gt;&lt;p&gt;首次渲染（首次挂载）前被调用，通过这个方法可以在组件被render前最后一次修改组件的state。&lt;/p&gt;
&lt;h4 id=&quot;render&quot;&gt;&lt;a href=&quot;#render&quot; class=&quot;headerlink&quot; title=&quot;render&quot;&gt;&lt;/a&gt;render&lt;/h4&gt;&lt;p&gt;render方法会创建一个虚拟DOM，其返回值可以是：null、false或React组件，只能返回一个顶级组件。React会将它和真实DOM做比较，以判断是否需要对DOM进行修改。&lt;/p&gt;
&lt;h4 id=&quot;componentDidMount&quot;&gt;&lt;a href=&quot;#componentDidMount&quot; class=&quot;headerlink&quot; title=&quot;componentDidMount&quot;&gt;&lt;/a&gt;componentDidMount&lt;/h4&gt;&lt;p&gt;真实的DOM已经被渲染后该方法被调用，可以在componentDidMount方法内部通过this.getDOMNode()访问到它。当需要访问原始DOM属性，可以将这些操作挂载到这个方法上。&lt;/p&gt;
&lt;h3 id=&quot;存在期&quot;&gt;&lt;a href=&quot;#存在期&quot; class=&quot;headerlink&quot; title=&quot;存在期&quot;&gt;&lt;/a&gt;存在期&lt;/h3&gt;&lt;p&gt;在这个时期，组件已经渲染好并且用户可以与它进行交互，用户的操作会改变组件的state，这时会有新的state流注入到组件树，这时会有一些方法会被触发。&lt;/p&gt;
&lt;p&gt;state改变后，会有以下方法会被触发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;componentWillReceiveProps&lt;/li&gt;
&lt;li&gt;shouldComponentUpdate&lt;/li&gt;
&lt;li&gt;componentWillUpdate&lt;/li&gt;
&lt;li&gt;render&lt;/li&gt;
&lt;li&gt;componentDidUpdate&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;componentWillReceiveProps&quot;&gt;&lt;a href=&quot;#componentWillReceiveProps&quot; class=&quot;headerlink&quot; title=&quot;componentWillReceiveProps&quot;&gt;&lt;/a&gt;componentWillReceiveProps&lt;/h4&gt;&lt;p&gt;当组件的props属性被修改时，该方法会被调用，这时我们可以获得修改的props对象和更新的state。&lt;/p&gt;
&lt;h4 id=&quot;shouldComponentUpdate&quot;&gt;&lt;a href=&quot;#shouldComponentUpdate&quot; class=&quot;headerlink&quot; title=&quot;shouldComponentUpdate&quot;&gt;&lt;/a&gt;shouldComponentUpdate&lt;/h4&gt;&lt;p&gt;该方法接收到修改的props对象和更新的state，当我们确定组件不需要重新渲染新的props或state时，可以通过该方法返回false，这样React就会跳过调用render方法及之后的componentWillUpdate和componentDidUpdate方法。&lt;/p&gt;
&lt;h4 id=&quot;componentWillUpdate&quot;&gt;&lt;a href=&quot;#componentWillUpdate&quot; class=&quot;headerlink&quot; title=&quot;componentWillUpdate&quot;&gt;&lt;/a&gt;componentWillUpdate&lt;/h4&gt;&lt;p&gt;发生在组件在接收到新的props或state后，render方法进行渲染之前&lt;/p&gt;
&lt;h4 id=&quot;componentDidUpdate&quot;&gt;&lt;a href=&quot;#componentDidUpdate&quot; class=&quot;headerlink&quot; title=&quot;componentDidUpdate&quot;&gt;&lt;/a&gt;componentDidUpdate&lt;/h4&gt;&lt;p&gt;与componentDidMount方法类似，这个方法使我们可以获取到已经渲染好的DOM。&lt;/p&gt;
&lt;h3 id=&quot;组件销毁&quot;&gt;&lt;a href=&quot;#组件销毁&quot; class=&quot;headerlink&quot; title=&quot;组件销毁&quot;&gt;&lt;/a&gt;组件销毁&lt;/h3&gt;&lt;p&gt;当使用完一个组件时，需要将其从DOM中卸载并销毁，这时只有componentWillUnmount一个函数会被调用，通过这个方法我们可以完成一些必要的销毁和清理工作，如：清除componentDidMount中添加的任务等。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;学习iOS时我们会去研究视图控制器的生命周期，理解控制器从创建到销毁。联想到React，其组件也有从创建到销毁的过程。在组件的生命周期中，随着组件props或state的改变，其DOM表现形式也会有所变化。在生命周期的不同阶段，React提供了不同的处理函数使我们能够实现对组件整个生命周期内的控制和处理。
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>iOS9和Xcode7中 Stack Views 介绍</title>
    <link href="http://yoursite.com/2016/04/23/iOS9%E5%92%8CXcode7%E4%B8%AD-Stack-Views-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2016/04/23/iOS9和Xcode7中-Stack-Views-介绍/</id>
    <published>2016-04-23T03:56:14.000Z</published>
    <updated>2016-04-23T05:01:11.000Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;原文：&lt;a href=&quot;http://www.appcoda.com/stack-views-intro/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;An Introduction to Stack Views in iOS 9 and Xcode 7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;此前，我们已经谈到了swift2的新功能，从这个教程开始，我们将含盖iOS9中的一些很酷的新功能。iOS新版本中添加了许多新特新。对于开发者来说，Stack View的介绍值得首提。我知道有些开发者发现使用自动布局来设计复杂的用户界面很困难。Stack views正是为了帮助我们，使开发人员的工作变得更容易。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Stack View提供了一个简化的接口将视图集合布局在任何一列或行。对于嵌入到Stack View的视图，你不再需要定义auto layout约束。Stack View管理其子视图的布局同时为你自动添加auto layout约束。这意味着子视图将能适应不同的屏幕尺寸。此外，您还可以将Stack View嵌入另一个Stack View来构建更复杂的用户界面。不要误会我的意思。这并不意味着你不需要处理的自动布局。你仍然需要定义Stack View布局约束。它只是从为每一个UI元素添加约束节省您的时间，使用户能够轻松地从布局添加/删除视图。&lt;/p&gt;
&lt;p&gt;Xcode中7提供了两种方式来使用Stack View。您可以从对象库中拖出一个Stack View（水平/垂直），并把它的拖到storyboard中。然后，您拖放视图对象，如标签，按钮，图像视图到Stack View中。另外，您也可以使用自动布局栏中的Stack选项。对于这种方法，您只需选择两个或多个视图对象，然后单击Stack选项。Interface Builder会将对象嵌入到Stack View中，并自动调整其大小。如果你还没有思绪关于如何使用堆栈视图，不用担心。我们将在本教程中介绍这两个方法。读下去，你就会很快明白我的意思。&lt;/p&gt;
&lt;p&gt;我假设你有autolayout的基础。如果没有，请首先阅读有关自动布局的&lt;a href=&quot;http://http://www.appcoda.com/introduction-auto-layout/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;介绍文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Demo-App&quot;&gt;&lt;a href=&quot;#Demo-App&quot; class=&quot;headerlink&quot; title=&quot;Demo App&quot;&gt;&lt;/a&gt;Demo App&lt;/h3&gt;&lt;p&gt;让我们先来看看我们要构建演示程序。在本教程中，我将告诉你如何像这样使用StackView布局一个用户界面：&lt;br&gt;&lt;img src=&quot;./stackview-1.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;你可以不使用StackView创建相同的UI。但正如你所看到的，StackView改变了你布局界面的方式。有在本教程中没有编码。我们将只专注于使用Interface Builder布局用户界面。&lt;/p&gt;
&lt;p&gt;首先，请下载&lt;a href=&quot;https://www.dropbox.com/s/n8qeg6rsreatqfe/StackViewDemoStarter.zip?dl=0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;初始项目&lt;/a&gt;。您需要使用的Xcode7来构建项目。如果你还没有安装它，请先下载它。项目模板非常简单。它仅预置的导航控制器和图像资源在image asset中。&lt;/p&gt;
&lt;p&gt;友情提示：样品照片由&lt;a href=&quot;http://magdeleine.co/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;magdeleine.co&lt;/a&gt;提供。&lt;/p&gt;
&lt;h3 id=&quot;从对象库中添加Stack-Views&quot;&gt;&lt;a href=&quot;#从对象库中添加Stack-Views&quot; class=&quot;headerlink&quot; title=&quot;从对象库中添加Stack Views&quot;&gt;&lt;/a&gt;从对象库中添加Stack Views&lt;/h3&gt;&lt;p&gt;启动Xcode 7，打开Main.storyboard。从对象库中，将一个Verticle Stack View对象拖到storyboard视图控制器中。Stack view 可以排列子视图（称为arranged views）在纵向和横向的布局。因为我们要垂直布局中的图像视图，我们选择Verticle堆栈视图对象。&lt;br&gt;&lt;img src=&quot;./stackview-2.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;接下来，从对象库中拖一个imageview。当你把imageview拖进stack view，imageview自动调整大小。重复相同的步骤，再增加两个imageview到stack view。这时候神奇发生了。当您添加另一个imageView，stack view自动调整imageView垂直的布局，为你建立必要的约束。酷吧？&lt;/p&gt;
&lt;h3 id=&quot;为Stack-View添加约束&quot;&gt;&lt;a href=&quot;#为Stack-View添加约束&quot; class=&quot;headerlink&quot; title=&quot;为Stack View添加约束&quot;&gt;&lt;/a&gt;为Stack View添加约束&lt;/h3&gt;&lt;p&gt;Stack View帮助开发人员添加每个布局对象的约束。话虽这么说，你需要提供堆栈视图的布局约束。对于我们刚才添加的Stack View，我们将添加如下布局约束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置Stack View的顶部，左侧和右侧间距约束，使得Stack View位于屏幕的顶部。&lt;/li&gt;
&lt;li&gt;设置Stack View的高度约​​束，使得Stack View高为父视图高的70％。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在选择StackView，然后单击布局按钮的Pin按钮。分别设置的顶部，左侧和右侧的约束为10，0和0。然后点击“Add 3 Constraints”按钮来添加约束。&lt;br&gt;&lt;img src=&quot;./stackview-3.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;StackView的当前位置不匹配约束。您可以直接点击警告标志（即黄色箭头）在文档大纲修复错位。&lt;/p&gt;
&lt;p&gt;要设置高度约​​束，选择Interface Builder的文档大纲。按住control从StackView拖到View。释放按钮后，选择的高度相等。&lt;br&gt;&lt;img src=&quot;./stackview-4.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;设置以后StackView的高度等于View的高度。然而，StackView应该只占View的高度的70％左右。因此，选择“StackView.height”约束，进入属性检查器。将值从乘数1.0更改为0.7。&lt;br&gt;&lt;img src=&quot;./stackview-5.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置Stack-Views的属性&quot;&gt;&lt;a href=&quot;#设置Stack-Views的属性&quot; class=&quot;headerlink&quot; title=&quot;设置Stack Views的属性&quot;&gt;&lt;/a&gt;设置Stack Views的属性&lt;/h3&gt;&lt;p&gt;StackView看起来并不如预期。一旦你有一个StackView，你可以改变一些堆栈视图的属性来改变它的外观。Axis选项表示所排列的视图是否应该布局垂直或水平。Alignment选项控制视图如何对齐排列。例如，如果它被设置为Leading，StackView对齐其前沿排列其子视图。&lt;br&gt;&lt;img src=&quot;./stackview-6.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Distribution选项定义排列的视图的大小和位置。缺省情况下，它被设置为Fill。在这种情况下，StackView会尽可能满足其可用空间排列所有子视图。现在，改变这个选项为Fill Equally。StackView会自动调整子视图的排列和大小，子视图相同的大小。&lt;br&gt;&lt;img src=&quot;./stackview-7.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Spacing选项允许你设置视图之间的间距。其值更改为10为image views之间添加额外的间距。&lt;br&gt;&lt;img src=&quot;./stackview-8.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置图片&quot;&gt;&lt;a href=&quot;#设置图片&quot; class=&quot;headerlink&quot; title=&quot;设置图片&quot;&gt;&lt;/a&gt;设置图片&lt;/h3&gt;&lt;p&gt;接下来，让我们为image views添加相应的图片。选择第一个imageView，然后转到属性检查器。改变image选项“nature-1”和将Mode设置为“Aspect Fill”。同时启用“Clip Subviews”。对其余image views重复相同的步骤操作，设置Image为“nature-2”和“nature-3”。您的布局应该是这样的：&lt;br&gt;&lt;img src=&quot;./stackview-9.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;现在，您可以运行该项目有一个快速浏览一下。尝试在不同的模拟器测试项目，用户界面​​完全适合于各种设备。StackView已为你自动添加布局约束。其实你可以启动视图调试选项（在运行你的应用程序），查看添加image views的布局约束。&lt;br&gt;&lt;img src=&quot;./stackview-10.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用嵌套的Stack-Views布局Labels和Buttons&quot;&gt;&lt;a href=&quot;#使用嵌套的Stack-Views布局Labels和Buttons&quot; class=&quot;headerlink&quot; title=&quot;使用嵌套的Stack Views布局Labels和Buttons&quot;&gt;&lt;/a&gt;使用嵌套的Stack Views布局Labels和Buttons&lt;/h3&gt;&lt;p&gt;我们还没有完成。有几个Label和Button需要添加到用户界面。现在从对象库的视图中拖一个Label。命名为“Nature”将它移动到StackView的右下方。通过改变其字体大小为30使Label大一点。接下来，拖一个Label至视图并命名为“A collection of nature photos from magdeleine.co”。将它放置在Naturelabel下面。&lt;/p&gt;
&lt;p&gt;同样，你也不需要为这些Label设置约束。让SackView替你去完成。在本教程的一开始，我提到，有使用SackView有两种方式。此前，从对象库中的添加SackView。现在，我会告诉你另一种方法。&lt;/p&gt;
&lt;p&gt;按住Command键来选择这两个Label，然后单击布局栏中的堆栈按钮。Interface Builder自动将这些Label嵌入到垂直SackView。&lt;br&gt;&lt;img src=&quot;./stackview-11.gif&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;接下来，向这个视图中添加两个button。命名一个为“Like”，另一个为“Share”。同样，我们也不想处理自动布局。因此，选择这两个button，然后单击布局栏中的Stack按钮在水平StackView中嵌入两个按钮。您可以通过设置StackView的间距值为5给按钮​​之间添加间隔。&lt;br&gt;&lt;img src=&quot;./stackview-12.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;如果你看一下最终的布局，两个Button应该放在 Nature Label旁边。你怎么能做到这一点？StackView优秀的地方是你可以将多个StackView嵌套在一起打造你想要的精确布局。现在拖动含Button的StackView到Nature Label的视图中。一旦你松开按键，StackView将在另一个StackView嵌入。Nature Label和Button，选择这两个视图，使用Stack选项将它们添加到StackView中。默认情况下，新的堆栈视图的轴被设置为垂直。在属性检查器中，将其更改为水平的，使Like和Share Button将位于Nature label右边。&lt;br&gt;&lt;img src=&quot;./stackview-13.gif&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Button还需要与Nature Label的基线对齐。选择StackView的Alignment选项将值由Fill改为First Baseline。另外，改变Spacing选项值为20来增加Nature Label与Button之间间距。&lt;br&gt;&lt;img src=&quot;./stackview-14.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;正如你所看到的，我们只需要使用嵌套StackView来构建你期望的精确布局。&lt;/p&gt;
&lt;p&gt;最后，我们添加含有imageView的StackView与含有Label和Button的StackView之间的约束，选中这两个StackView然后单击布局按钮的Pin按钮。分别设置顶部，左，右的值为0,8和0。&lt;br&gt;&lt;img src=&quot;./stackview-15.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;为了确保说明Label自动调整大小，更改Lines选项为0和Line Breaks选项为Word Wrap。好的！您已经完成了UI设计。现在运行项目，看看结果。如果你一切配置正确，您的用户界面应该是这样的：&lt;br&gt;&lt;img src=&quot;./stackview-16.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;如果您在横向iPhone上查看布局，用户界面​​变成这样：&lt;br&gt;&lt;img src=&quot;./stackview-17.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;它看起来不错，但是如果能像这样水平的排列是不是更棒？&lt;br&gt;&lt;img src=&quot;./stackview-18.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用Size-Classe适配StackView&quot;&gt;&lt;a href=&quot;#使用Size-Classe适配StackView&quot; class=&quot;headerlink&quot; title=&quot;使用Size Classe适配StackView&quot;&gt;&lt;/a&gt;使用Size Classe适配StackView&lt;/h3&gt;&lt;p&gt;为iPhone横向实现不同布局，我们必须使StackView具有适应性。在iOS中8，介绍了size classe的概念。下表显示了iOS设备及其相应size class：&lt;br&gt;&lt;img src=&quot;./stackview-19.png&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;您可以使用size classe提供指定的布局覆盖原有的基础布局中的设计。在这种情况下，我们要为这两个size class将StackView（含有imageView）的Sxis由vertical改为horizontal：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compact width-Compact height&lt;/li&gt;
&lt;li&gt;Regular width-Compact height&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选中StackVIew并转到属性检查器。点击Axis选项左侧的+按钮。选择Any Width&amp;gt;Compact height，然后设置这个尺寸级别的Axis为Horizontal。any width 包括compact和regular width。&lt;br&gt;&lt;img src=&quot;./stackview-20.gif&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;通过这样做，当你的iPhone旋转的时候StackView将水平排列这些imageView。在不同的设备上运行并查看结果。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;在本教程中，我已经给你介绍了StackView，并就如何使用这种新的组件布局UI进行了演示。StackView用很少的约束简化你构建在iOS用户界面的方式。你可能有一个问题是，你何时应使用StackView？苹果工程师建议开发人员除了在确实需要约束的时候，其他时候优先采用StackView。开始使用StackView设计您的用户界面！我相信你会爱上它。&lt;/p&gt;
&lt;p&gt;作为参考，你可以在&lt;a href=&quot;https://github.com/appcoda/uistackview-demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里下载Xcode项目&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;原文：&lt;a href=&quot;http://www.appcoda.com/stack-views-intro/&quot;&gt;An Introduction to Stack Views in iOS 9 and Xcode 7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;此前，我们已经谈到了swift2的新功能，从这个教程开始，我们将含盖iOS9中的一些很酷的新功能。iOS新版本中添加了许多新特新。对于开发者来说，Stack View的介绍值得首提。我知道有些开发者发现使用自动布局来设计复杂的用户界面很困难。Stack views正是为了帮助我们，使开发人员的工作变得更容易。&lt;br&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="布局" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Xcode的Targets来管理开发和生产构建</title>
    <link href="http://yoursite.com/2016/04/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Xcode%E7%9A%84Targets%E6%9D%A5%E7%AE%A1%E7%90%86%E5%BC%80%E5%8F%91%E5%92%8C%E7%94%9F%E4%BA%A7%E6%9E%84%E5%BB%BA/"/>
    <id>http://yoursite.com/2016/04/10/如何使用Xcode的Targets来管理开发和生产构建/</id>
    <published>2016-04-10T02:43:32.000Z</published>
    <updated>2016-04-10T03:06:57.000Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;原文：&lt;a href=&quot;https://guides.cocoapods.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;How to Use Xcode Targets to Manage Development and Production Builds&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;参加&lt;a href=&quot;http://www.cocoachina.com/ios/20160331/15832.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaChina&lt;/a&gt;翻译活动时所译&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;编者提示：这篇文章由Eugene Trapeznikov贡献。想象一下，你已经完成了您的应用程序的开发和测试，你现在准备提交生产版本。问题是，一些web服务的url指向测试服务器，同时API密钥被配置用于测试环境。在提交app给苹果审核前，你需要修改所有这些API密钥和URL适应生产版本。这听起来不错，对吧？但是相较于在开发和生产环境之间来回切换，有没有更好的方法来处理开发和生产的构建？这正是接下来Eugene要和你们讨论的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;进入Eugene的教程&quot;&gt;&lt;a href=&quot;#进入Eugene的教程&quot; class=&quot;headerlink&quot; title=&quot;进入Eugene的教程&quot;&gt;&lt;/a&gt;进入Eugene的教程&lt;/h3&gt;&lt;p&gt;对于初学者来说，有些人可能会奇怪，为什么你需要使用两个单独的数据库和环境同时开发应用程序。原因是当你继续构建新的功能特性或继续开发你的应用，你希望区分开现有的公开版本和开发版本。标准的软件开发实践是在不同的开发环境下开发不同版本的软件，像我们案例中讲到的开发iphone应用。开发版本的应用程序通常使用一个不同的不同于生产环境的数据库(或如分析的其他系统)。这就是为什么我们应该为不同的环境中使用单独的服务器和数据库。开发人员在测试期间通常都使用虚拟图像或虚拟数据。在测试环境中，使用诸如 “test comment”, “argharghargh” 和 “one more test comment”之类的测试数据并不少见。显然，你不希望你的真实用户看到这样的消息。如果你的应用程序使用了一个分析系统的情况下，你甚至会在测试阶段发送成千上万的事件。同样的,你不会把测试数据和生产数据放在同一个数据库中。这就是为什么总是推荐区分开发和生产环境。&lt;/p&gt;
&lt;p&gt;在使用两个独立的环境时，你的应用程序需要有一个办法，找出它应该连接到的环境。一种常用的方法是在你的主应用代理里定义一个全局变量，将您的应用程序初始化为开发或生产模式。&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enum environmentType &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case development, production&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; environmen&lt;span class=&quot;variable&quot;&gt;t:environmentType&lt;/span&gt; = .production&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;switch environment &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case .developmen&lt;span class=&quot;variable&quot;&gt;t:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; web service URL &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; development&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; API &lt;span class=&quot;built_in&quot;&gt;keys&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; development&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;It&#39;s for development&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case .production:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; web service URL &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; production&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; API &lt;span class=&quot;built_in&quot;&gt;keys&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; production&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;It&#39;s for production&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方法需要你每次切换环境时改变全局变量。虽然这种方法也许快捷，方便，但是它有一些重要的限制。首先，因为我们在开发和生产两个环境中使用一个Bundle ID，你不能在一台设备上安装这两个版本的应用。当你需要要测试开发版本的应用程序,同时仍在该设备上使用生产版本的应用，这就变的不方便了。此外，这种方法很有可能将开发版本的应用上传到应用商店。如果你忘记了改变这个全局变量，你将会上传错误的应用给你的用户。我记得有一次在提交应用程序到应用商店之前我忘记改变全局变量，用户获取到开发版本的应用。这是可怕的。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将向你们展示一个更好的方法来区分开发和生产构建。具体而言，我们将在Xcode中创建一个开发的target。这种方法法适用于新的和现有的大型项目，所以你可以用一个现有的应用程序对照本教程。&lt;/p&gt;
&lt;p&gt;通过应用这种方法,生产和开发版本的应用程序将具有相同的基础代码，但可以有不同的图标,bundle ID 和指向不同的数据库。发布和提交过程将会非常简单。最重要的是,你的测试人员和经理可以在同一设备上安装两个版本的应用程序,所以他们完全知道他们在尝试哪个版本。&lt;/p&gt;
&lt;h3 id=&quot;如何创建一个新的Target&quot;&gt;&lt;a href=&quot;#如何创建一个新的Target&quot; class=&quot;headerlink&quot; title=&quot;如何创建一个新的Target&quot;&gt;&lt;/a&gt;如何创建一个新的Target&lt;/h3&gt;&lt;p&gt;所以你如何在Xcode中创建一个开发的target?我使用示例项目“todo”引导您一步一步完成整个过程。。您也可以使用自己的项目并按照步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在项目的导航面板进入项目设置。在Targets区域下，右键单击现有目标并选择 &lt;code&gt;Duplicate&lt;/code&gt; 复制现有的目标。&lt;br&gt;&lt;img src=&quot;./cocoachina_1.png&quot; width=&quot;800&quot; height=&quot;400&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Xcode会询问你新的target是否是为iPad开发。对于本教程,我们只是选择“Duplicate Only”。&lt;br&gt;&lt;img src=&quot;./cocoachina_2.png&quot; width=&quot;800&quot; height=&quot;300&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;code&gt;提示：如果您的项目支持通用设备,Xcode不会提示上述消息。&lt;/code&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在我们有一个名为&lt;code&gt;todo copy&lt;/code&gt;的新的target和build scheme。让我们重命名它使它更容易理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Targets列表中选择新的target。 按Enter键来编辑文本,添加一个更合适的名字。我更倾向于 “todo Dev”. 你自由选择任何你喜欢的名字。&lt;/li&gt;
&lt;li&gt;接下来，转到“Manage Schemes…”, 选择您在步骤1中创建的shceme,并按“输入”。 使scheme的名称和新的target的名称相同(这是一个对于新的target的选择)&lt;br&gt;&lt;img src=&quot;./cocoachina_3.png&quot; width=&quot;800&quot; height=&quot;360&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;步骤4是可选的,但强烈推荐。如果你想简单地区分开发和生产构建，你应该为每个版本使用单独的图标和启动页。这将使你的测试人员更清晰的知道正在使用哪个app,防止你上传开发版本。😃&lt;/p&gt;
&lt;p&gt; 跳到 &lt;code&gt;Assets.xcassets&lt;/code&gt; 添加一个新的图标。右击图标 &amp;gt; &lt;strong&gt;App Icons &amp;amp; Launch Images&lt;/strong&gt; &amp;gt; &lt;strong&gt;New iOS App Icon&lt;/strong&gt;. 新图标重命名为“AppIcon-Dev”同时添加自己的图片。&lt;br&gt;&lt;img src=&quot;./cocoachina_4.jpg&quot; width=&quot;800&quot; height=&quot;500&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在回到项目设置,选择您的开发target改变bundle identifier。你可以简单地将“Dev”追加到原来的ID上。如果执行了步骤4，请确保更改应用app icon，设置为在上一步中创建的。&lt;br&gt;&lt;img src=&quot;./cocoachina_5.png&quot; width=&quot;800&quot; height=&quot;500&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Xcode 自动为你的target添加plist文件(如todo copy-Info.plist)。你可以在项目的根文件夹找到它。将它从“copy”重命名为“Dev”,并将它放在原始的plist文件下。这里你将更容易管理文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在打开你开发target的“Build Settings”，滚动到“Packaging”，并将值改为开发的plist文件（todo Dev.plist）。&lt;br&gt;&lt;img src=&quot;./cocoachina_6.png&quot; width=&quot;800&quot; height=&quot;400&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后，我们会为生产和开发target配置预处理宏/编译器标识。之后我们就可以使用该标识在我们的代码来检测应用程序正在运行的版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于Objective-C的项目，去到&lt;code&gt;Build Settings&lt;/code&gt;下Apple &lt;code&gt;LLVM 7.0 - Preprocessing&lt;/code&gt;。拓展&lt;code&gt;Preprocessor Macros&lt;/code&gt;在Rebug和Release区域添加一个变量。对于开发target（即todo Dev），将该值设置为&lt;code&gt;DEVELOPMENT = 1&lt;/code&gt;。另一个，将值设为&lt;code&gt;DEVELOPMENT=0&lt;/code&gt;来表示生产版本。&lt;br&gt;&lt;img src=&quot;./cocoachina_7.png&quot; width=&quot;800&quot; height=&quot;310&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;./cocoachina_8.png&quot; width=&quot;800&quot; height=&quot;310&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;对于swift的项目，编译器不再支持预处理指令。作为替代，它使用编译时的属性和build配置。选中开发target，添加一个标识表示开发版本。去到&lt;code&gt;Build Setting&lt;/code&gt;往下滚动到&lt;code&gt;Swift Compiler - Custom Flags&lt;/code&gt;部分。将值设为&lt;code&gt;-DDEVELOPMENT&lt;/code&gt;表示这个target作为开发版本。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./cocoachina_9.png&quot; width=&quot;800&quot; height=&quot;300&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;现在，您已经创建并配置了开发target，下一步呢？&lt;/p&gt;
&lt;h3 id=&quot;使用Target和宏&quot;&gt;&lt;a href=&quot;#使用Target和宏&quot; class=&quot;headerlink&quot; title=&quot;使用Target和宏&quot;&gt;&lt;/a&gt;使用Target和宏&lt;/h3&gt;&lt;p&gt;根据已配置的宏DEV_VERSION，我们可以在代码中利用它动态地编译项目。下面是一个简单的例子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Objective-C:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; DEVELOPMENT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SERVER_URL @&lt;span class=&quot;string&quot;&gt;&quot;http://dev.server.com/api/&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; API_TOKEN @&lt;span class=&quot;string&quot;&gt;&quot;DI2023409jf90ew&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SERVER_URL @&lt;span class=&quot;string&quot;&gt;&quot;http://prod.server.com/api/&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; API_TOKEN @&lt;span class=&quot;string&quot;&gt;&quot;71a629j0f090232&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Objective-C中你可以使用&lt;code&gt;＃if&lt;/code&gt;检查&lt;code&gt;DEVELOPMENT&lt;/code&gt;的环境，并相应的设置URLs/ API密钥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swift:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#if DEVELOPMENT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;SERVER_URL&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;http://dev.server.com/api/&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;API_TOKEN&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;DI2023409jf90ew&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;SERVER_URL&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;http://prod.server.com/api/&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;API_TOKEN&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;71a629j0f090232&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Swift中你仍然可以使用&lt;code&gt;#if&lt;/code&gt;判定build的参数动态编译。然而，除了使用&lt;code&gt;#define&lt;/code&gt;定义基本常量，在swift中我们也可以用&lt;code&gt;let&lt;/code&gt;定义一个全局常量。&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;提示:通常，你会把上面的代码放在app &lt;span class=&quot;keyword&quot;&gt;delegate&lt;/span&gt;中。但这最终是取决于你在哪里初始化应用程序设置。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，当您选择“todo Dev”scheme运行项目，你创建开发版本会自动将服务器的配置设置为开发环境。现在，您可以上传开发版本到TestFlight 或 HockeyApp供测试人员和管理人员来测试。&lt;/p&gt;
&lt;p&gt;接着如果你需要创建一个生产版本，您可以简单地选择”todo”scheme。不需要更改代码。&lt;/p&gt;
&lt;h3 id=&quot;管理多个target的一些注意事项&quot;&gt;&lt;a href=&quot;#管理多个target的一些注意事项&quot; class=&quot;headerlink&quot; title=&quot;管理多个target的一些注意事项&quot;&gt;&lt;/a&gt;管理多个target的一些注意事项&lt;/h3&gt;&lt;p&gt;1.当你添加新的文件到项目中，不要忘记选择两个target，以保持你的代码同步在两个版本。&lt;br&gt;&lt;img src=&quot;./cocoachina_10.png&quot; width=&quot;800&quot; height=&quot;400&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;2.如果你使用的CocoaPods，不要忘了添加新的target到你的podfile中。您可以使用&lt;code&gt;link_with&lt;/code&gt;指定多个target。您可以进一步细节请查阅的 &lt;a href=&quot;https://guides.cocoapods.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;CocoaPods&lt;/strong&gt;&lt;/a&gt; 文档。你的podfile看起来是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight mel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;https://github.com/CocoaPods/Specs.git&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;platform :ios, &lt;span class=&quot;string&quot;&gt;&#39;7.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;workspace&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;todo&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;link_with &lt;span class=&quot;string&quot;&gt;&#39;todo&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;todo Dev&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &lt;span class=&quot;string&quot;&gt;&#39;Mixpanel&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &lt;span class=&quot;string&quot;&gt;&#39;AFNetworking&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.如果你使用持续集成系统，如 Travis CI 或Jenkins，别忘了配置两个target的build和deliver。&lt;/p&gt;
&lt;p&gt;你对这个教程有什么想法？如何管理你的开发和生产构建？给我留言评论分享您的想法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;原文：&lt;a href=&quot;https://guides.cocoapods.org/&quot;&gt;&lt;strong&gt;How to Use Xcode Targets to Manage Development and Production Builds&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;参加&lt;a href=&quot;http://www.cocoachina.com/ios/20160331/15832.html&quot;&gt;CocoaChina&lt;/a&gt;翻译活动时所译&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;编者提示：这篇文章由Eugene Trapeznikov贡献。想象一下，你已经完成了您的应用程序的开发和测试，你现在准备提交生产版本。问题是，一些web服务的url指向测试服务器，同时API密钥被配置用于测试环境。在提交app给苹果审核前，你需要修改所有这些API密钥和URL适应生产版本。这听起来不错，对吧？但是相较于在开发和生产环境之间来回切换，有没有更好的方法来处理开发和生产的构建？这正是接下来Eugene要和你们讨论的。&lt;br&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>iOS中category添加属性</title>
    <link href="http://yoursite.com/2015/10/07/iOS%E4%B8%ADcategory%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2015/10/07/iOS中category添加属性/</id>
    <published>2015-10-07T08:15:39.000Z</published>
    <updated>2015-10-07T08:19:32.000Z</updated>
    
    <content type="html">&lt;p&gt;我们知道，使用Category可以很方便地为现有的类增加方法，但却无法直接增加实例变量。不过从Mac OS X v10.6开始，系统提供了Associative References，这个问题就很容易解决了。这种方法也就是所谓的关联(association)，我们可以在runtime期间动态地添加任意多的属性，并且随时读取。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;所用到的两个重要runtime API是：&lt;/p&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OBJC_EXPORT &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; objc_setAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; value, objc_AssociationPolicy policy)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OBJC_EXPORT &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__OSX_&lt;span class=&quot;built_in&quot;&gt;AVAILABLE_STARTING&lt;/span&gt;(__MAC_10_6, __IPHONE_3_1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;例：&lt;/code&gt;我们现在打算利用category对UILabel进行属性补充。一般我们有个原则：&lt;code&gt;能用category扩展就不用继承，因为随着继承深度的增加，代码的可维护性也会增加很多。&lt;/code&gt;使用category可以这么做：&lt;/p&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;objc/runtime.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UILabel&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;Associate&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *labelId;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UILabel&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;Associate&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@dynamic&lt;/span&gt; labelId;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; labelIdKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setLabelId:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)labelId &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_setAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &amp;amp;labelIdKey, labelId, OBJC_ASSO&lt;span class=&quot;built_in&quot;&gt;CIATION_COPY_NONATOMIC&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)labelId &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, &amp;amp;labelIdKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;key：我们注意到在函数签名中key的类型const void *，这表示key仅仅是一个地址。关键字是一个void类型的指针。每一个关联的关键字必须是唯一的。通常都是会采用静态变量来作为关键字。&lt;/li&gt;
&lt;li&gt;policy：这里的policy跟属性声明中的retain、assign、copy是一样的，不再赘述。关联策略表明了相关的对象是通过赋值，保留引用还是复制的方式进行关联的；还有这种关联是原子的还是非原子的。这里的关联策略和声明属性时的很类似。这种关联策略是通过使用预先定义好的常量来表示的。&lt;/li&gt;
&lt;li&gt;在implement开始处的@dynamic声明。@dynamic则告诉编译器，编译阶段不用为我生成setter与getter，在runtime我已经自己实现了setter与getter。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;延伸阅读&quot;&gt;&lt;a href=&quot;#延伸阅读&quot; class=&quot;headerlink&quot; title=&quot;延伸阅读&quot;&gt;&lt;/a&gt;延伸阅读&lt;/h3&gt;&lt;h3 id=&quot;关联对象相关的BlocksKit&quot;&gt;&lt;a href=&quot;#关联对象相关的BlocksKit&quot; class=&quot;headerlink&quot; title=&quot;关联对象相关的BlocksKit&quot;&gt;&lt;/a&gt;关联对象相关的BlocksKit&lt;/h3&gt;&lt;p&gt;BlocksKit是对Cocoa Touch Block编程更进一步的支持，它简化了Block编程，发挥Block的相关优势，让更多UIKit类支持Block式编程。&lt;/p&gt;
&lt;p&gt;详细了解blockskit参见&lt;a href=&quot;http://blog.csdn.net/cshun1990/article/details/45462031&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlocksKit源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关联对象相关的BlocksKit是对objc_setAssociatedObject、objc_getAssociatedObject、objc_removeAssociatedObjects这几个原生关联对象函数的封装。主要是封装其其内存管理语义。&lt;/p&gt;
&lt;p&gt;部分函数声明如下：&lt;/p&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//@interface NSObject (BKAssociatedObjects)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//以OBJC_ASSOCIATION_RETAIN_NONATOMIC方式绑定关联对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)bk_associateValue:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)value withKey:(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//以OBJC_ASSOCIATION_COPY_NONATOMIC方式绑定关联对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)bk_associateCopyOfValue:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)value withKey:(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//以OBJC_ASSOCIATION_RETAIN方式绑定关联对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)bk_atomicallyAssociateValue:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)value withKey:(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//以OBJC_ASSOCIATION_COPY方式绑定关联对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)bk_atomicallyAssociateCopyOfValue:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)value withKey:(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//弱绑定&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)bk_weaklyAssociateValue:(__autoreleasing &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)value withKey:(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//删除所有绑定的关联对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)bk_removeAllAssociatedObjects;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了弱绑定以外，其它BlocksKit函数都是简单封装。弱绑定有点扩展关联对象原生语义的感觉。&lt;/p&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_BKWeakAssociatedObject&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)bk_weaklyAssociateValue:(__autoreleasing &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)value withKey:(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _BKWeakAssociatedObject *assoc = objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!assoc) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        assoc = [_BKWeakAssociatedObject new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//做一个_BKWeakAssociatedObject对象中间层&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//以非原子持有的方式绑定一个_BKWeakAssociatedObject对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//_BKWeakAssociatedObject该对象又有真实对象的弱引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; bk_associateValue:assoc withKey:key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//_BKWeakAssociatedObject的weak property设置为真正应该关联的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assoc.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从以上实现代码可以看出，所谓弱绑定实际上是在关联对象之间做了一个中间层，让本对象以OBJC_ASSOCIATION_RETAIN_NONATOMIC的形式去关联中间层（_BKWeakAssociatedObject），而中间层又以weak property的形式去存储真正关联对象的指针。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，使用Category可以很方便地为现有的类增加方法，但却无法直接增加实例变量。不过从Mac OS X v10.6开始，系统提供了Associative References，这个问题就很容易解决了。这种方法也就是所谓的关联(association)，我们可以在runtime期间动态地添加任意多的属性，并且随时读取。
    
    </summary>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
      <category term="基础+" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>block的一些基础</title>
    <link href="http://yoursite.com/2015/09/29/block%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2015/09/29/block的一些基础/</id>
    <published>2015-09-29T11:56:56.000Z</published>
    <updated>2015-10-03T09:31:15.000Z</updated>
    
    <content type="html">&lt;p&gt;在异步编程时我们经常进行函数回调，由于函数调用是异步执行的，我们如果想让一个操作执行完之后执行另一个函数，则无法按照正常代码书写顺序进行编程，因为我们无法获知前一个方法什么时候执行结束，此时我们经常会用到委托或者代码块（Block）。Block就是一个函数体（匿名函数），它是ObjC对于闭包的实现，在块状中我们可以持有或引用局部变量，同时利用Block你可以将一个操作作为一个参数进行传递（是不是想起了C语言中的函数指针）。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;block定义&quot;&gt;&lt;a href=&quot;#block定义&quot; class=&quot;headerlink&quot; title=&quot;block定义&quot;&gt;&lt;/a&gt;block定义&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Block类型定义：&lt;font color=&quot;#EF4700&quot;&gt;&lt;strong&gt;返回值类型(^ 变量名)(参数列表)&lt;/strong&gt;&lt;/font&gt;（注意Block也是一种类型）；&lt;/li&gt;
&lt;li&gt;Block的typedef定义：&lt;font color=&quot;#EF4700&quot;&gt;&lt;strong&gt;返回值类型(^类型名称)(参数列表)&lt;/strong&gt;&lt;/font&gt;；&lt;/li&gt;
&lt;li&gt;Block的实现：&lt;font color=&quot;#EF4700&quot;&gt;&lt;strong&gt;^(参数列表){操作主体}&lt;/strong&gt;&lt;/font&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;block与存取变量&quot;&gt;&lt;a href=&quot;#block与存取变量&quot; class=&quot;headerlink&quot; title=&quot;block与存取变量&quot;&gt;&lt;/a&gt;block与存取变量&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可以读取和Block pointer同一個范围的变量值&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (^myBlock) (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) = ^(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a + b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; result = myBlock(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%d&quot;&lt;/span&gt;,result);&lt;span class=&quot;comment&quot;&gt;//结果是9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上，myBlock在实现部分用到a這個变量值的时候是把a的值copy下來。所以之后a即使改变了对于myBlock里copy的值是沒有影响的&lt;/p&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; * mutableArray = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; arrayWithObjects:&lt;span class=&quot;string&quot;&gt;@&quot;one&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;@&quot;two&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;@&quot;three&quot;&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^myBlock1)(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *) = ^(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *array) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [array removeLastObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock1(mutableArray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;test array %@&quot;&lt;/span&gt;, mutableArray);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果這個变量的值是个pointer的話，它指到的值是可以在block里被改变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接存取 static 的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a2 = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (^myBlock2) (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) = ^(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a2 + b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a2 = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; result2 = myBlock2(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;result2:%d&quot;&lt;/span&gt;,result2);&lt;span class=&quot;comment&quot;&gt;//结果是 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Block 变量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a3 = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (^myBlock3) (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) = ^(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a3 + b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a3 = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; result3 = myBlock3(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;result3:%d&quot;&lt;/span&gt;,result3);&lt;span class=&quot;comment&quot;&gt;//结果是 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在某個变量前面如果加上修饰字 __block 的話(注意block前有兩個下划线)，這個变量又叫做block variable（变量）。那在block里就可以任意修改此变量值，变量值的变化也可以知道。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;补充：&lt;/code&gt; __block 和 __weak修饰符的区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。&lt;/li&gt;
&lt;li&gt;__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型(int)。&lt;/li&gt;
&lt;li&gt;__block对象可以在block中被重新赋值，__weak不可以。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;block与引用循环&quot;&gt;&lt;a href=&quot;#block与引用循环&quot; class=&quot;headerlink&quot; title=&quot;block与引用循环&quot;&gt;&lt;/a&gt;block与引用循环&lt;/h3&gt;&lt;p&gt;retain cycle问题的根源在于Block和obj可能会互相强引用，互相retain对方，这样就导致了retain cycle，最后这个Block和obj就变成了孤岛，谁也释放不了谁。&lt;/p&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^CustomBlock)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) CustomBlock myBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_myBlock = ^() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//警告self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;直接循环引用。&lt;/p&gt;
&lt;p&gt;ViewController –强引用——&amp;gt;_myBlock(堆block,会retain 内部引用对象变量)&lt;/p&gt;
&lt;p&gt;_myBlock——retain———&amp;gt;self(ViewController)&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^CustomBlock)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BlockTester&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; statusCode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) CustomBlock myBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)useBlock:(CustomBlock)block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt; () &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BlockTester *_blockTester;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_blockTester.myBlock = ^() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//警告self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;间接循环引用。&lt;/p&gt;
&lt;p&gt;ViewController —–retain–&amp;gt; _blockTester&lt;/p&gt;
&lt;p&gt;_blockTester ——-强引用—&amp;gt;myBlock(堆block,会retain 内部引用对象变量)&lt;/p&gt;
&lt;p&gt;myBlock  —retain———&amp;gt;self(ViewController)&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_async&lt;/span&gt;(dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;1:%@&quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//没有警告self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;self 并没有直接或间接的去强引用 gcd block。 可以想象 gcd block 会统一被管理在调度中心来管理，反正不是self。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight obj-c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[_blockTester useBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (_blockTester.statusCode == &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;2:%@&quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//没有警告self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;栈block 并不会对内部引用对象变量 retain.而是直接引用对象变量地址。&lt;/p&gt;
&lt;p&gt;这里 self 和  _blockTester 并没有对 方法参数block 做任何引用操作，block 一直存在于栈上，直到执行完毕被释放掉。&lt;/p&gt;
&lt;p&gt;当然block 也没有对self  做任何操作，直接引用了地址。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;喜欢block的同学，推荐了解&lt;/code&gt; &lt;a href=&quot;https://github.com/zwaldowski/BlocksKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlocksKit&lt;/a&gt;    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在异步编程时我们经常进行函数回调，由于函数调用是异步执行的，我们如果想让一个操作执行完之后执行另一个函数，则无法按照正常代码书写顺序进行编程，因为我们无法获知前一个方法什么时候执行结束，此时我们经常会用到委托或者代码块（Block）。Block就是一个函数体（匿名函数），它是ObjC对于闭包的实现，在块状中我们可以持有或引用局部变量，同时利用Block你可以将一个操作作为一个参数进行传递（是不是想起了C语言中的函数指针）。
    
    </summary>
    
    
      <category term="block" scheme="http://yoursite.com/tags/block/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>动画基础之CALayer</title>
    <link href="http://yoursite.com/2015/09/28/%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%E4%B9%8BCALayer/"/>
    <id>http://yoursite.com/2015/09/28/动画基础之CALayer/</id>
    <published>2015-09-28T11:33:11.000Z</published>
    <updated>2015-10-03T09:31:06.000Z</updated>
    
    <content type="html">&lt;p&gt;之所以介绍CALayer，是因为CALayer是深入了解iOS动画开发的重要基础内容。CALayer包含在QuartzCore框架中，这是一个跨平台的框架，既可以用在iOS中又可以用在Mac OS X中。在使用Core Animation开发动画的本质就是将CALayer中的内容转化为位图从而供硬件操作，所以要熟练掌握动画操作必须先来熟悉CALayer。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在UIView中有一个layer属性作为根图层，根图层上可以放其他子图层，在UIView中所有能够看到的内容都包含在layer中。&lt;/p&gt;
&lt;p&gt;在iOS中CALayer的设计主要是了为了内容展示和动画操作，CALayer本身并不包含在UIKit中，它不能响应事件。&lt;br&gt;    由于CALayer在设计之初就考虑它的动画操作功能，    CALayer很多属性在修改时都能形成动画效果，这种属性称为“隐式动画属性”。&lt;br&gt; 但是对于UIView的根图层而言属性的修改并不形成动画效果，因为很多情况下根图层更多的充当容器的做用，如果它的属性变动形成动画效果会直接影响子图层。另外，UIView的根图层创建工作完全由iOS负责完成，无法重新创建，但是可以往根图层中添加子图层或移除子图层。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;是否支持隐式动画&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;anchorPoint&lt;/td&gt;
&lt;td&gt;和中心点position重合的一个点，称为“锚点”，锚点的描述是相对于x、y位置比例而言的默认在图像中心点(0.5,0.5)的位置&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backgroundColor&lt;/td&gt;
&lt;td&gt;图层背景颜色&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;borderColor&lt;/td&gt;
&lt;td&gt;边框颜色&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;borderWidth&lt;/td&gt;
&lt;td&gt;边框宽度&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bounds&lt;/td&gt;
&lt;td&gt;图层大小&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contents&lt;/td&gt;
&lt;td&gt;图层显示内容，例如可以将图片作为图层内容显示&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contentsRect&lt;/td&gt;
&lt;td&gt;图层显示内容的大小和位置&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cornerRadius&lt;/td&gt;
&lt;td&gt;圆角半径&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;doubleSided&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;图层背面是否显示，默认为YES&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;否&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;frame&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;图层大小和位置，不支持隐式动画，所以CALayer中很少使用frame，通常使用bounds和position代替&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;否&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hidden&lt;/td&gt;
&lt;td&gt;是否隐藏&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mask&lt;/td&gt;
&lt;td&gt;图层蒙版&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;maskToBounds&lt;/td&gt;
&lt;td&gt;子图层是否剪切图层边界，默认为NO&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;opacity&lt;/td&gt;
&lt;td&gt;透明度 ，类似于UIView的alpha&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;position&lt;/td&gt;
&lt;td&gt;图层中心点位置，类似于UIView的center&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shadowColor&lt;/td&gt;
&lt;td&gt;阴影颜色&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shadowOffset&lt;/td&gt;
&lt;td&gt;阴影偏移量&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shadowOpacity&lt;/td&gt;
&lt;td&gt;阴影透明度，注意默认为0，如果设置阴影必须设置此属性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shadowPath&lt;/td&gt;
&lt;td&gt;阴影的形状&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shadowRadius&lt;/td&gt;
&lt;td&gt;阴影模糊半径&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sublayers&lt;/td&gt;
&lt;td&gt;子图层&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sublayerTransform&lt;/td&gt;
&lt;td&gt;子图层形变&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transform&lt;/td&gt;
&lt;td&gt;图层形变&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;隐式属性动画的本质是这些属性的变动默认隐含了CABasicAnimation动画实现。&lt;/li&gt;
&lt;li&gt;在CALayer中很少使用frame属性，因为frame本身不支持动画效果，通常使用bounds和position代替。&lt;/li&gt;
&lt;li&gt;CALayer中透明度使用opacity表示而不是alpha；中心点使用position表示而不是center。&lt;/li&gt;
&lt;li&gt;anchorPoint属性是图层的锚点，范围在（0~1,0~1）表示在x、y轴的比例，这个点永远可以同position（中心点）重合，当图层position固定后，调整anchorPoint即可达到调整图层显示位置的作用（因为它永远和position重合）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;obj-c&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad {
    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];
    &lt;span class=&quot;comment&quot;&gt;// Do any additional setup after loading the view, typically from a nib.&lt;/span&gt;
    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; drawCustomLayer];
}

&lt;span class=&quot;comment&quot;&gt;// 绘制图层&lt;/span&gt;
- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)drawCustomLayer {
    &lt;span class=&quot;built_in&quot;&gt;CGSize&lt;/span&gt; size = [&lt;span class=&quot;built_in&quot;&gt;UIScreen&lt;/span&gt; mainScreen].bounds.size;
    &lt;span class=&quot;comment&quot;&gt;//创建图层&lt;/span&gt;
    _layer = [[&lt;span class=&quot;built_in&quot;&gt;CALayer&lt;/span&gt; alloc] init];
    &lt;span class=&quot;comment&quot;&gt;//设置背景颜色,由于QuartzCore是跨平台框架，无法直接使用UIColor&lt;/span&gt;
    _layer.backgroundColor = [&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; colorWithRed:&lt;span class=&quot;number&quot;&gt;0.657&lt;/span&gt; green:&lt;span class=&quot;number&quot;&gt;1.000&lt;/span&gt; blue:&lt;span class=&quot;number&quot;&gt;0.712&lt;/span&gt; alpha:&lt;span class=&quot;number&quot;&gt;1.000&lt;/span&gt;].CGColor;
    &lt;span class=&quot;comment&quot;&gt;//设置中心点(中心点使用position而不是center)&lt;/span&gt;
    _layer.position=&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(size.width/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, size.height/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);
    _layer.bounds = &lt;span class=&quot;built_in&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, Width, Width);
    _layer.cornerRadius = Width / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;
    &lt;span class=&quot;comment&quot;&gt;//设置阴影&lt;/span&gt;
    _layer.shadowColor = [&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; colorWithRed:&lt;span class=&quot;number&quot;&gt;0.765&lt;/span&gt; green:&lt;span class=&quot;number&quot;&gt;0.284&lt;/span&gt; blue:&lt;span class=&quot;number&quot;&gt;0.289&lt;/span&gt; alpha:&lt;span class=&quot;number&quot;&gt;1.000&lt;/span&gt;].CGColor;
    _layer.shadowOffset = &lt;span class=&quot;built_in&quot;&gt;CGSizeMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);
    _layer.shadowOpacity = &lt;span class=&quot;number&quot;&gt;0.8&lt;/span&gt;;
    &lt;span class=&quot;comment&quot;&gt;//设置锚点(永远和position重合),CGPointZero equivalent to CGPointMake(0, 0)&lt;/span&gt;
    _layer.anchorPoint = &lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//CGPointZero;&lt;/span&gt;

    &lt;span class=&quot;comment&quot;&gt;//加到根图层&lt;/span&gt;
    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.layer addSublayer:_layer];
}

&lt;span class=&quot;comment&quot;&gt;//点击旋转（放大，缩小，平移... 通过修改position和bounds均可产生动画）&lt;/span&gt;
- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)touchesBegan:(&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; *)touches withEvent:(&lt;span class=&quot;built_in&quot;&gt;UIEvent&lt;/span&gt; *)event {
    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (index == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {
        _layer.transform = &lt;span class=&quot;built_in&quot;&gt;CATransform3DMakeScale&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);
        index = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
    }
    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
        _layer.transform = &lt;span class=&quot;built_in&quot;&gt;CATransform3DMakeScale&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);
        index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当点击屏幕时会有旋转动画，在点击屏幕的时候修改图层的属性，这些属性的变动默认隐含了CABasicAnimation动画实现。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之所以介绍CALayer，是因为CALayer是深入了解iOS动画开发的重要基础内容。CALayer包含在QuartzCore框架中，这是一个跨平台的框架，既可以用在iOS中又可以用在Mac OS X中。在使用Core Animation开发动画的本质就是将CALayer中的内容转化为位图从而供硬件操作，所以要熟练掌握动画操作必须先来熟悉CALayer。
    
    </summary>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>NSString内存相关特性strong、copy</title>
    <link href="http://yoursite.com/2015/09/20/NSString%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7strong%E3%80%81copy/"/>
    <id>http://yoursite.com/2015/09/20/NSString内存相关特性strong、copy/</id>
    <published>2015-09-20T13:55:29.000Z</published>
    <updated>2015-10-03T09:31:29.000Z</updated>
    
    <content type="html">&lt;p&gt;在声明一个NSString属性时，对于其内存相关特性，通常有两种选择( &lt;strong&gt;基于ARC环境&lt;/strong&gt; )：strong与copy。大部分的时候NSString的属性都是copy，那copy与strong的情况下到底有什么区别呢？&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;示例&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们定义一个类，并为其声明两个字符串属性，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@property (nonatomic, strong) NSString *strongString;
@property (nonatomic, copy) NSString *copyedString;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码声明了两个字符串属性，其中一个内存特性是strong，一个是copy。下面我们来看看它们的区别。&lt;/p&gt;
&lt;p&gt;首先，我们用一个不可变字符串来为这两个属性赋值，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)stringTest {
    NSString *string = [NSString stringWithFormat:@&amp;quot;test&amp;quot;];
    self.strongString = string;
    self.copyedString = string;
    NSLog(@&amp;quot;原字符串:%p %p %@&amp;quot;,string,&amp;amp;string,string);
    NSLog(@&amp;quot;strongString:%p %p %@&amp;quot;,_strongString,&amp;amp;_strongString,_strongString);
    NSLog(@&amp;quot;copyedString:%p %p %@&amp;quot;,_copyedString,&amp;amp;_copyedString,_copyedString);
    //改变string
    string = @&amp;quot;123&amp;quot;;
    NSLog(@&amp;quot;原字符串:%p %p %@&amp;quot;,string,&amp;amp;string,string);
    NSLog(@&amp;quot;strongString:%p %p %@&amp;quot;,_strongString,&amp;amp;_strongString,_strongString);
    NSLog(@&amp;quot;copyedString:%p %p %@&amp;quot;,_copyedString,&amp;amp;_copyedString,_copyedString);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其输出结果是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;原字符串:0x7473657445 0x7fff5fbff7d8 test
strongString:0x7473657445 0x100206d78 test
copyedString:0x7473657445 0x100206d80 test

原字符串:0x100005260 0x7fff5fbff7d8 123
strongString:0x7473657445 0x100206d78 test
copyedString:0x7473657445 0x100206d80 test                        
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们要以看到，这种情况下，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string指向的地址。但此时改变string值，实际改变了string指向的地址，strongString、copyedString任指向原地址，显示源地址内容“test”。&lt;/p&gt;
&lt;p&gt;接下来，我们把string由不可变改为可变对象，看看会是什么结果。即将下面这一句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)mutableStringTest {
    NSMutableString *string = [NSMutableString stringWithFormat:@&amp;quot;test&amp;quot;];
    self.strongString = string;
    self.copyedString = string;
    NSLog(@&amp;quot;原字符串:%p %p %@&amp;quot;,string,&amp;amp;string,string);
    NSLog(@&amp;quot;strongString:%p %p %@&amp;quot;,_strongString,&amp;amp;_strongString,_strongString);
    NSLog(@&amp;quot;copyedString:%p %p %@&amp;quot;,_copyedString,&amp;amp;_copyedString,_copyedString);
    //改变string
    [string appendString:@&amp;quot;123&amp;quot;];
    NSLog(@&amp;quot;原字符串:%p %p %@&amp;quot;,string,&amp;amp;string,string);
    NSLog(@&amp;quot;strongString:%p %p %@&amp;quot;,_strongString,&amp;amp;_strongString,_strongString);
    NSLog(@&amp;quot;copyedString:%p %p %@&amp;quot;,_copyedString,&amp;amp;_copyedString,_copyedString);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其输出结果是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;原字符串:0x100114cd0 0x7fff5fbff7d8 test
strongString:0x100114cd0 0x100106ef8 test
copyedString:0x7473657445 0x100106f00 test

原字符串:0x100114cd0 0x7fff5fbff7d8 test123
strongString:0x100114cd0 0x100106ef8 test123
copyedString:0x7473657445 0x100106f00 test
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，我们如果去修改string字符串的话，因为_strongString与string是指向同一对象，所以_strongString的值也会跟随着改变(&lt;code&gt;需要注意的是，此时_strongString的类型实际上是NSMutableString，而不是NSString&lt;/code&gt;)；可以看到：而_copyedString是指向另一个对象的，所以并不会改变。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;font size=&quot;4&quot; color=&quot;green&quot;&gt;结论&lt;/font&gt;

&lt;p&gt;而上面的例子可以看出，当源字符串是NSString时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。&lt;/p&gt;
&lt;p&gt;当源字符串是NSMutableString时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。&lt;/p&gt;
&lt;p&gt;所以，在声明NSString属性时，到底是选择strong还是copy，可以根据实际情况来定。不过，一般我们将对象声明为NSString时，都不希望它改变，所以大多数情况下，我们建议用copy，以免因可变字符串的修改导致的一些非预期问题。&lt;/p&gt;
&lt;p&gt;比如声明的一个NSString *str变量，然后把一个NSMutableString *mStr变量的赋值给它了，如果要求str跟着mStr变化，那么就用retain;如果str不能跟着mStr一起变化，那就用copy。而对于要把NSString类型的字符串赋值给str，那两都没啥区别。不会影响安全性，内存管理也一样。&lt;/p&gt;
&lt;p&gt;关于字符串的内存管理，还有些有意思的东西，可以参考 &lt;a href=&quot;http://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSString特性分析学习&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在声明一个NSString属性时，对于其内存相关特性，通常有两种选择( &lt;strong&gt;基于ARC环境&lt;/strong&gt; )：strong与copy。大部分的时候NSString的属性都是copy，那copy与strong的情况下到底有什么区别呢？
    
    </summary>
    
    
      <category term="NSString" scheme="http://yoursite.com/tags/NSString/"/>
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发ARC内存管理</title>
    <link href="http://yoursite.com/2015/09/19/iOS%E5%BC%80%E5%8F%91ARC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2015/09/19/iOS开发ARC内存管理/</id>
    <published>2015-09-19T13:43:52.000Z</published>
    <updated>2015-10-03T09:31:22.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;ARC&lt;/code&gt;  &lt;code&gt;内存管理&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;在了解ARC之前，先了解OC内存管理里面的&lt;code&gt;对象生命周期&lt;/code&gt;、&lt;code&gt;引用计数&lt;/code&gt;、&lt;code&gt;对象所有权&lt;/code&gt; ，（自行查阅相关资料）&lt;/p&gt;
&lt;p&gt;本文简单介绍iOS开发中ARC(Automatic Reference Counting，&lt;code&gt;自动引用计数&lt;/code&gt;)内存管理的一些要点，所以不会讲的很全面。详细的关于ARC的信息请参见苹果的！&lt;a href=&quot;https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;与网上的其他教程） &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;本文的主要内容：&quot;&gt;&lt;a href=&quot;#本文的主要内容：&quot; class=&quot;headerlink&quot; title=&quot;本文的主要内容：&quot;&gt;&lt;/a&gt;本文的主要内容：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ARC的本质 &lt;/li&gt;
&lt;li&gt;__strong, __weak&lt;/li&gt;
&lt;li&gt;ARC与Toll-Free Bridging&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ARC的本质&quot;&gt;&lt;a href=&quot;#ARC的本质&quot; class=&quot;headerlink&quot; title=&quot;ARC的本质&quot;&gt;&lt;/a&gt;ARC的本质&lt;/h3&gt;&lt;p&gt;先引用官方的关于ARC的一句描述： &lt;/p&gt;
&lt;p&gt;Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications. &lt;/p&gt;
&lt;p&gt;ARC是编译器（时）特性，而不是运行时特性（关于运行时&lt;code&gt;runtime&lt;/code&gt;是深入学习iOS的重要内容，有兴趣的同学可以自己深入学习） &lt;/p&gt;
&lt;p&gt;ARC只是相对于MRC的改进，本质上依然是通过管理对象的引用计数。 &lt;/p&gt;
&lt;p&gt;如果你启用了ARC，只管像平常那样按需分配并使用对象，编译器会帮你插入retain和release语句。&lt;/p&gt;
&lt;h3 id=&quot;strong-weak&quot;&gt;&lt;a href=&quot;#strong-weak&quot; class=&quot;headerlink&quot; title=&quot;__strong, __weak&quot;&gt;&lt;/a&gt;__strong, __weak&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;__strong&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示引用为强引用。对应在定义property时的”strong”。所有对象只有当没有任何一个强引用指向时，才会被释放。&lt;/p&gt;
&lt;p&gt;注意：如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置nil。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__weak&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示引用为弱引用。对应在定义property时用的”weak”。弱引用不会影响对象的释放，即只要对象没有任何强引用指向，该对象依然会被释放。不过好在，对象在被释放的同时，指向它的弱引用会自动被置nil，这个技术叫zeroing weak pointer。这样有效得防止无效指针、野指针的产生。__weak一般用在block、delegate关系中防止循环引用或者用来修饰指向由Interface Builder编辑与生成的UI控件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@property (nonatomic,strong) NSString *myString;&lt;/p&gt;
&lt;p&gt;NSString __strong *myString;&lt;/p&gt;
&lt;p&gt;__strong关键字和strong特性不可同时使用，内存管理的关键字和特性是不能一起使用的，两者相互排斥。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;苹果的文档中明确地写道：&lt;/p&gt;
&lt;p&gt;You should decorate variables correctly. When using qualifiers in an object variable declaration,&lt;/p&gt;
&lt;p&gt;the correct format is:&lt;/p&gt;
&lt;p&gt;ClassName * qualifier variableName;&lt;/p&gt;
&lt;p&gt;按照这个说明，要定义一个weak型的NSString引用，它的写法应该是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString * __weak str = @&amp;quot;hehe&amp;quot;; // 正确！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而不应该是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__weak NSString *str = @&amp;quot;hehe&amp;quot;;  // 不推荐！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我相信很多人都和我一样，从开始用ARC就一直用上面那种错误的写法。&lt;/p&gt;
&lt;p&gt;那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道：&lt;/p&gt;
&lt;p&gt;Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, see&lt;a href=&quot;http://cdecl.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cdecl.org/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;好吧，看来是考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误。&lt;/p&gt;
&lt;h3 id=&quot;ARC与Toll-Free-Bridging&quot;&gt;&lt;a href=&quot;#ARC与Toll-Free-Bridging&quot; class=&quot;headerlink&quot; title=&quot;ARC与Toll-Free Bridging&quot;&gt;&lt;/a&gt;ARC与Toll-Free Bridging&lt;/h3&gt;&lt;p&gt;ARC只对可保留的对象指针有效。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码块指针&lt;/li&gt;
&lt;li&gt;Objective-C指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如CoreFoundation指针，CF指针由人工管理，手动的CFRetain和CFRelease来管理，注，CF中没有autorelease。&lt;/p&gt;
&lt;p&gt;CocoaFoundation指针与CoreFoundation指针转换，需要考虑的是所指向对象所有权的归属。ARC提供了3个修饰符来管理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;__bridge，什么也不做，仅仅是转换。此种情况下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从Cocoa转换到Core，需要人工CFRetain，否则，Cocoa指针释放后， 传出去的指针则无效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从Core转换到Cocoa，需要人工CFRelease，否则，Cocoa指针释放后，对象引用计数仍为1，不会被销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;__bridge_retained，转换后自动调用CFRetain，即帮助自动解决上述i的情形。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;__bridge_transfer，转换后自动调用CFRelease，即帮助自动解决上述ii的情形。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ARC&lt;/code&gt;  &lt;code&gt;内存管理&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;在了解ARC之前，先了解OC内存管理里面的&lt;code&gt;对象生命周期&lt;/code&gt;、&lt;code&gt;引用计数&lt;/code&gt;、&lt;code&gt;对象所有权&lt;/code&gt; ，（自行查阅相关资料）&lt;/p&gt;
&lt;p&gt;本文简单介绍iOS开发中ARC(Automatic Reference Counting，&lt;code&gt;自动引用计数&lt;/code&gt;)内存管理的一些要点，所以不会讲的很全面。详细的关于ARC的信息请参见苹果的！&lt;a href=&quot;https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;官方文档&lt;/a&gt;与网上的其他教程）
    
    </summary>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>从iOS的内存说起</title>
    <link href="http://yoursite.com/2015/09/19/%E4%BB%8EiOS%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%B4%E8%B5%B7/"/>
    <id>http://yoursite.com/2015/09/19/从iOS的内存说起/</id>
    <published>2015-09-19T08:30:22.000Z</published>
    <updated>2015-10-03T09:33:24.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;当启动一个app&quot;&gt;&lt;a href=&quot;#当启动一个app&quot; class=&quot;headerlink&quot; title=&quot;当启动一个app&quot;&gt;&lt;/a&gt;当启动一个app&lt;/h3&gt;&lt;p&gt;当启动一个app程序，系统会把开启的那个app程序从ROM里面拷贝到内存（RAM）&lt;em&gt;&lt;code&gt;RAM的访问速度要远高内存卡(Flash)或ROM&lt;/code&gt;&lt;/em&gt;，然后从内存里面执行。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;内存分区-可以分为5个区&quot;&gt;&lt;a href=&quot;#内存分区-可以分为5个区&quot; class=&quot;headerlink&quot; title=&quot;内存分区:可以分为5个区&quot;&gt;&lt;/a&gt;内存分区:可以分为5个区&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;栈区&lt;/strong&gt;（stack）— 这个一般由编译器操作，会存一些局部变量，函数跳转地址，现场保护等等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;堆区&lt;/strong&gt;（heap） — 一般由程序员管理，比如alloc申请内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;全局区&lt;/strong&gt;（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放。注意：全局区又可分为未初始化全局区：.bss段 和 初始化全局区：data段。举例：int a;未初始化的。int a = 10;已初始化的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;常量区&lt;/strong&gt; — 常量字符串就是放在这里的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码区&lt;/strong&gt; — 存放代码，即app程序会拷贝到这里&lt;em&gt;&lt;code&gt;app程序从ROM里面拷贝到内存（RAM）&lt;/code&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;编程中内存相关&quot;&gt;&lt;a href=&quot;#编程中内存相关&quot; class=&quot;headerlink&quot; title=&quot;编程中内存相关&quot;&gt;&lt;/a&gt;编程中内存相关&lt;/h3&gt;&lt;font color=&quot;#E95044&quot;&gt;当一个app启动后，代码区，常量区，全局区大小已固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这两个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（编程中很常见）。&lt;/font&gt;


&lt;h3 id=&quot;参考图&quot;&gt;&lt;a href=&quot;#参考图&quot; class=&quot;headerlink&quot; title=&quot;参考图&quot;&gt;&lt;/a&gt;参考图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/memery.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;当启动一个app&quot;&gt;&lt;a href=&quot;#当启动一个app&quot; class=&quot;headerlink&quot; title=&quot;当启动一个app&quot;&gt;&lt;/a&gt;当启动一个app&lt;/h3&gt;&lt;p&gt;当启动一个app程序，系统会把开启的那个app程序从ROM里面拷贝到内存（RAM）&lt;em&gt;&lt;code&gt;RAM的访问速度要远高内存卡(Flash)或ROM&lt;/code&gt;&lt;/em&gt;，然后从内存里面执行。
    
    </summary>
    
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
</feed>
